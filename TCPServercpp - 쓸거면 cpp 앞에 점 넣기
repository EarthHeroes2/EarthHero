#include <winsock2.h>
#include <ws2tcpip.h>
#include <cstdio>
#include <string>
#include <thread>
#include <cstring>
#include <vector>
#include <mysql.h>

#include <jdbc/cppconn/driver.h>
#include <jdbc/cppconn/exception.h>
#include <jdbc/cppconn/resultset.h>
#include <jdbc/cppconn/statement.h>
#include <jdbc/cppconn/prepared_statement.h>

#pragma comment(lib, "libmysql.lib")
#pragma comment(lib, "mysqlcppconn.lib")
#pragma comment(lib, "Ws2_32.lib")

#define SERVERPORT 7777
#define MAX_NUM_SERVERS 10
#define MAX_BUFFER_LENGTH 1000

using namespace std;

int bLobbyExist[MAX_NUM_SERVERS] = { false, };
string lobbyPassword[MAX_NUM_SERVERS];

vector<string> StringTokenizer(char* str)
{
    vector<string> tokens;
    char* token;
    char* context = NULL;

    token = strtok_s(str, "|", &context);

    while (token != NULL)
    {
        tokens.push_back(string(token));
        token = strtok_s(NULL, "|", &context);
    }

    return tokens;
}

//서버 인스턴스 실행만 시키고 리턴됨
void CreateNewLobbyInstance(const wchar_t* Command, int LobbyNumber)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    //초기화
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(
        NULL,
        const_cast<wchar_t*>(Command),
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi)
        )
    {
        fprintf(stderr, "CreateProcess failed : % lu\n", GetLastError());
        return;
    }

    bLobbyExist[LobbyNumber] = true;

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

string CreateNewLobby(const string* lobbyName, const string* isPrivate, const string* password)
{
    string unrealPath = "C:\\UnrealEngine-5.1.1-release\\Engine\\Binaries\\Win64\\UnrealEditor.exe"; //소스빌드 UnrealEditor.exe 경로
    string projectPath = "C:\\Git\\EarthHero\\EarthHero.uproject"; //우리 프로젝트 uproject 경로
    string portNumber = "";

    for (int lobbyNumber = 0; lobbyNumber < MAX_NUM_SERVERS; lobbyNumber++)
    {
        if (!bLobbyExist[lobbyNumber])
        {
            lobbyPassword[lobbyNumber] = *password; //비번 할당

            portNumber = to_string(lobbyNumber + 7778);
            string command = unrealPath + " " + projectPath + " Lobby -server -log"
                + " -Port=" + portNumber
                + " -QueryPort=" + to_string(stoi(portNumber) + 19238)
                + " -LobbyName=" + *lobbyName
                + " -Private=" + *isPrivate;

            //문자열 변환...
            wstring wCommand(command.begin(), command.end());
            const wchar_t* wCharCommand = wCommand.c_str();
            CreateNewLobbyInstance(wCharCommand, lobbyNumber);

            return portNumber;
        }
    }
    return portNumber;
}





bool InsertData(MYSQL* connection, int id, int score)
{
    string query = "INSERT INTO test_table (id, score) VALUES (" +
        to_string(id) + ", " +
        to_string(score) + ")";

    if (mysql_query(connection, query.c_str()))
    {
        fprintf(stderr, "INSERT failed. Error: %s\n", mysql_error(connection));
        return false;
    }
    return true;
}





int main()
{
    MYSQL* conn, connection;

    const char* host = "localhost";
    const char* user = "root";
    const char* passwd = "자신의 비밀번호";
    const char* db = "test_schema";
    
    if(mysql_init(&connection) == NULL)
    {
        fprintf(stderr, "mysql_init failed\n");
        return 1;
    }
    if ((conn = mysql_real_connect(&connection, host, user, passwd, db, 3306, NULL, 0)) == NULL)
    {
        fprintf(stderr, "mysql_real_connect failed : %s\n", mysql_error(&connection));
        mysql_close(&connection);
        return 1;
    }

    if (InsertData(conn, 123, 100)) printf("Insert Data Successs\n");
    else fprintf(stderr, "Insert Data Failed\n");





























    WSADATA wsaData;
    int iResult;

    // Winsock 초기화
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
    {
        fprintf(stderr, "WSAStartup failed: %d", iResult);
        return 1;
    }

    // 소켓 생성
    SOCKET ListenSocket = INVALID_SOCKET;
    ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ListenSocket == INVALID_SOCKET)
    {
        fprintf(stderr, "Socket creation failed: %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // 주소 및 포트 설정
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(SERVERPORT);


    // 소켓 바인드
    iResult = ::bind(ListenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));
    if (iResult == SOCKET_ERROR) {
        fprintf(stderr, "Bind failed: %d", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }


    // 소켓 리슨
    iResult = listen(ListenSocket, SOMAXCONN);
    if (iResult == SOCKET_ERROR)
    {
        fprintf(stderr, "Listen failed: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    printf("Waiting for connections...\n");

    while (true)
    {
        // 클라이언트 연결 수락
        SOCKET ClientSocket;
        ClientSocket = accept(ListenSocket, NULL, NULL);
        if (ClientSocket == INVALID_SOCKET)
        {
            fprintf(stderr, "Accept failed: %d\n", WSAGetLastError());
            closesocket(ListenSocket);
            WSACleanup();
            return 1;
        }

        char buffer[MAX_BUFFER_LENGTH] = { 0 };
        iResult = recv(ClientSocket, buffer, MAX_BUFFER_LENGTH, 0);

        if (iResult > 0)
        {
            vector<string> tokens = StringTokenizer(buffer); //토큰으로 자르고
            size_t numTokens = tokens.size();

            string request = tokens[0];

            if (request == "CreateLobby" && numTokens == 4)
            {
                //새로운 서버 열고 해당 포트 번호 리턴
                string newServerPortString = CreateNewLobby(&tokens[1], &tokens[2], &tokens[3]);
                const char* newServerPort = newServerPortString.c_str();

                //플레이어에게 접속할 포트 번호 알려줌
                send(ClientSocket, newServerPort, strlen(newServerPort) + 1, 0);

                printf("Send new server port : %s\n", newServerPort);
            }
            else if (request == "DestroyServer" && numTokens == 2)
            {
                string destroyServerPort = tokens[1];

                printf("Destroy server port : %s\n", destroyServerPort.c_str());

                int lobbyNumber = stoi(destroyServerPort) - 7778;
                bLobbyExist[lobbyNumber] = false;
            }
            else if (request == "ComparePassword" && numTokens == 3)
            {
                int selectedLobbyNumber = stoi(tokens[1]) - 7778;
                string password = tokens[2];

                printf("Receive Password : %s         Correct Password : %s\n", password.c_str(), lobbyPassword[selectedLobbyNumber].c_str());

                string compareResultString;
                if (password == lobbyPassword[selectedLobbyNumber]) compareResultString = "true";
                else compareResultString = "false";

                const char* compareResult = compareResultString.c_str();
                send(ClientSocket, compareResult, strlen(compareResult) + 1, 0);
            }
            else if (request == "UpdateData") // 미구현
            {
                printf("data : %s\n", tokens[1].c_str());


                //SavePlayerScore(con, playerID, score);
            }
            else
            {
                printf("Invalid request : %s\n", request.c_str());
            }
        }
        else
        {
            printf("Receive failed: %d\n", WSAGetLastError());
        }

        closesocket(ClientSocket);
    }
    closesocket(ListenSocket);
    WSACleanup();

    return 0;
}