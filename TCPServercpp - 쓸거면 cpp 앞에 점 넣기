#include <winsock2.h>
#include <ws2tcpip.h>
#include <cstdio>
#include <string>
#include <thread>
#include <cstring>
#include <vector>

using namespace std;

#pragma comment(lib, "Ws2_32.lib")

#define SERVERPORT 7777
#define MAX_NUM_SERVERS 10
#define MAX_BUFFER_LENGTH 1000


int bLobbyExist[MAX_NUM_SERVERS] = {false, };
string lobbyPassword[MAX_NUM_SERVERS];


vector<string> StringTokenizer(char *str)
{
    vector<string> tokens;
    char *token;
    char *context = NULL;
    
    token = strtok_s(str, "|", &context);
    
    while (token != NULL)
    {
        tokens.push_back(string(token));
        token = strtok_s(NULL, "|", &context);
    }

    return tokens;
}

//서버 인스턴스 실행만 시키고 리턴됨
void CreateNewLobbyInstance(const wchar_t* Command, int LobbyNumber)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    //초기화
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    
    if (!CreateProcess(
        NULL,
        const_cast<wchar_t*>(Command),
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi )
    )
    {
        printf("CreateProcess failed: %lu\n", GetLastError());
        return;
    }
    
    bLobbyExist[LobbyNumber] = true;
    
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

string CreateNewLobby(const string *lobbyName, const string *isPrivate, const string *password)
{
    string unrealPath = "C:\\UnrealEngine-5.1.1-release\\Engine\\Binaries\\Win64\\UnrealEditor.exe"; //소스빌드 UnrealEditor.exe 경로
    string projectPath = "C:\\Git\\EarthHero\\EarthHero.uproject"; //우리 프로젝트 uproject 경로
    string portNumber = "";

    for(int lobbyNumber = 0; lobbyNumber < MAX_NUM_SERVERS; lobbyNumber++)
    {
        if(!bLobbyExist[lobbyNumber])
        {
            lobbyPassword[lobbyNumber] = *password; //비번 할당
            
            portNumber = to_string(lobbyNumber + 7778);
            string command = unrealPath + " " + projectPath + " Lobby -server -log"
                            + " -Port=" + portNumber
                            + " -QueryPort=" + to_string(stoi(portNumber) + 19238)
                            + " -LobbyName=" + *lobbyName
                            + " -Private=" + *isPrivate;
            
            //문자열 변환...
            std::wstring wCommand(command.begin(), command.end());
            const wchar_t* wCharCommand = wCommand.c_str();   
            CreateNewLobbyInstance(wCharCommand, lobbyNumber);
            
            return portNumber;
        }
    }
    return portNumber;
}


int main()
{
    WSADATA wsaData;
    int iResult;
    
    // Winsock 초기화
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
    {
        printf("WSAStartup failed: %d", iResult);
        return 1;
    }
    
    // 소켓 생성
    SOCKET ListenSocket = INVALID_SOCKET;
    ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ListenSocket == INVALID_SOCKET)
    {
        printf("Socket creation failed: %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // 주소 및 포트 설정
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(SERVERPORT);

    
    // 소켓 바인드
    iResult = bind(ListenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));
    if (iResult == SOCKET_ERROR) {
        printf("Bind failed: %d", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    
    // 소켓 리슨
    iResult = listen(ListenSocket, SOMAXCONN);
    if (iResult == SOCKET_ERROR)
    {
        printf("Listen failed: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }
    
    printf("Waiting for connections...\n");

    while (true)
    {
        // 클라이언트 연결 수락
        SOCKET ClientSocket;
        ClientSocket = accept(ListenSocket, NULL, NULL);
        if (ClientSocket == INVALID_SOCKET)
        {
            printf("Accept failed: %d\n", WSAGetLastError());
            closesocket(ListenSocket);
            WSACleanup();
            return 1;
        }
        
        char buffer[MAX_BUFFER_LENGTH] = {0};
        iResult = recv(ClientSocket, buffer, MAX_BUFFER_LENGTH, 0);
        
        if (iResult > 0)
        {
            vector<string> tokens = StringTokenizer(buffer); //토큰으로 자르고
            int numTokens = tokens.size();

            string request = tokens[0];
            
            if(request == "CreateLobby" && numTokens == 4)
            {
                //새로운 서버 열고 해당 포트 번호 리턴
                string newServerPortString = CreateNewLobby(&tokens[1], &tokens[2], &tokens[3]); 
                const char* newServerPort = newServerPortString.c_str();

                //플레이어에게 접속할 포트 번호 알려줌
                send(ClientSocket, newServerPort, strlen(newServerPort) + 1, 0);
                
                printf("Send new server port : %s\n",  newServerPort);
            }
            else if(request == "DestroyServer" && numTokens == 2)
            {
                string destroyServerPort = tokens[1];
                
                printf("Destroy server port : %s\n", destroyServerPort.c_str());
                
                int lobbyNumber = stoi(destroyServerPort) - 7778;
                bLobbyExist[lobbyNumber] = false;
            }
            else if(request == "ComparePassword" && numTokens == 3)
            {
                int selectedLobbyNumber = stoi(tokens[1]) - 7778;
                string password = tokens[2];

                printf("Receive Password : %s         Correct Password : %s\n", password.c_str(), lobbyPassword[selectedLobbyNumber].c_str());

                string compareResultString;
                if(password == lobbyPassword[selectedLobbyNumber])
                {
                    printf("equal\n");
                    compareResultString = "true";
                }
                else
                {
                    printf("not equal\n");
                    compareResultString = "false";
                }
                const char* compareResult = compareResultString.c_str();
                send(ClientSocket, compareResult, strlen(compareResult) + 1, 0);
            }
            else if(request == "UpdateData") // 미구현
            {
                printf("data : %s\n", tokens[1].c_str());
            }
            else
            {
                printf("Invalid request : %s\n", request.c_str());
            }
        }
        else
        {
            printf("Receive failed: %d\n", WSAGetLastError());
        }
        
        closesocket(ClientSocket);
    }
    closesocket(ListenSocket);
    WSACleanup();

    return 0;
}